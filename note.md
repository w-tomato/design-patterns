# Java设计模式笔记
## 一、创建型模式
对象实例化的模式，创建型模式用于解耦对象的实例化过程。
### 1.1 [单例模式](src/main/java/org/bradaier/designpatterns/creational/singleton/DCL.java)
    最简单的就是饿汉，直接初始化一个静态变量，每次有人调用getInstance()方法时，直接返回这个静态变量即可。
    但是这样的话，就会在类加载的时候就创建这个实例，如果这个实例很大，而且不一定会被使用，那么就会造成内存的浪费。
    所以，我们可以使用懒汉模式，也就是在第一次使用的时候才创建这个实例，但是这样的话，就会有线程安全的问题，所以我们可以使用双重检查锁定的方式来解决这个问题。
    但是这样的话，还是会有问题，就是在JVM中，创建对象和赋值是分开的，也就是说，可能会出现先赋值，后创建对象的情况，这样的话，就会出现问题。
    所以，我们可以使用volatile关键字来解决这个问题，这样的话，就会强制线程每次都去主内存中读取变量的值，而不是从线程的私有内存中读取变量的值。
    也可以使用静态内部类的方式来实现单例模式，这样的话，就可以保证线程安全，也可以保证懒加载，而且也不会有性能问题。
    最后，还可以使用枚举的方式来实现单例模式，这样的话，就可以保证线程安全，也可以保证懒加载，而且也不会有性能问题，而且还可以防止反序列化的时候创建新的对象。

### 1.2 [工厂模式](src/main/java/org/bradaier/designpatterns/creational/factory/abstractf/IProductFactory.java)
    简单工厂模式：我有一个大工厂，里面全是if else， 你告诉我你要啥车，宝马，奥迪都能造
    工厂方法模式：我有一个工厂接口，同时有多个具体的工厂实现这个接口，宝马工厂造宝马，奥迪工厂造奥迪，这样没了if else，要啥车就用啥工厂造
    抽象工厂模式：有两个维度
               第一个维度：我抽象出了一个手机产品接口，所有品牌的手机都得实现这个接口，同时抽象了一个路由器产品接口，所有品牌的路由器都得实现这个接口
               第二个维度：我抽象出了一个厂商接口，这个接口定义了要会生产手机，也要会生产路由器
               这样的好处就是两个维度都可以扩展。

### 1.3 [建造者模式](src/main/java/org/bradaier/designpatterns/creational/builder/demo1/AbstractBuilder.java) 
    建造者模式：就是一个抽象建造者类，这个抽象建造者类可以有多个具体的建造者类，这些具体的建造者类都继承自抽象建造者类，每个具体的建造者类都可以创建一种产品类的实例。
    与工厂模式的区别在于工厂模式最终目的是创建不同的对象，比如创建手机对象和路由器对象，但建造者模式是我就要建造手机，但是有的建造者建造手机用的是高通处理器，有的建造者建造手机用的是联发科处理器，这个可以由用户来自定义，而工厂模式是由工厂来决定的。
    所以也可以简单理解为工厂生产处不同的产品，而建造者生产相同的产品，但是产品的组成不同。

### 1.4 [原型模式](src/main/java/org/bradaier/designpatterns/creational/prototype/PrototypeObject.java)
    原型模式：定义一个原形对象，这个对象需要两个步骤，一个是实现Cloneable接口，一个是重写clone()方法，这个方法的返回值是这个对象的一个浅拷贝。
    当创建新的对象实例比从头开始构建更加昂贵或复杂时，使用原型模式可以通过复制现有对象来节省时间和资源。

## 二、结构型模式
从程序的结构上实现松耦合，从而可以扩大整体的类结构，用来解决更大的问题。
### 2.1 [适配器模式](src/main/java/org/bradaier/designpatterns/structural/adapter/XiaoMiAdapter.java)
    适配器模式：适配器模式适用于需要将现有的类或接口转换为其他类或接口以满足特定需求的场景
    比如Mac只有雷电3接口，插不了USB，就需要一个适配器来转换一下，这样就可以插USB了。详细看例子中解释
    而这个适配器可以是各个牌子的, 所以可以定义一个接口来定义功能，这些适配器都实现这个接口。
    当然U盘也可以是各个牌子的，所以也可以定义一个接口来定义功能，这些U盘都实现这个接口。
    其实核心就在于某个充当适配器或充当桥的类  有一个通过构造器传入的带一定功能方法的成员变量，这个成员变量可以是接口，也可以是抽象类，也可以是具体类。桥接模式也是这个思想。

### 2.2 [桥接模式](src/main/java/org/bradaier/designpatterns/structural/bridge/AbstractComputer.java)
    桥接模式：网上都说桥接模式适用于需要将抽象部分与其实现部分分离的场景，但是我分不清楚抽象部分和实现部分是什么，所以我就自己理解了一下。我觉得很像适配器模式，
    在上边的适配器模式中，电脑想用U盘，就需要适配器，但是U盘可以有很多牌子的，所以可以定义接口来供U盘实现，桥接模式的话我理解就是适配器例子中的电脑也有很多种，
    比如Mac，小米，华为，这些电脑都可以用U盘，但是他们的接口不一样，所以就需要一个抽象类来供各种电脑实现，而桥接模式不需要像适配器模式一样真的创建一个类来当做适配器，
    这个桥是一个想象中的桥，其实核心思想是一样的，就像上边适配器模式笔记的最后一句话，这里的桥接模式就是将电脑抽象出来一个抽象类，
    这个抽象类像适配器一样有一个成员变量，这个成员变量就是U盘的抽象类，这样电脑也抽象了，可以扩展了，U盘也抽象了，也可以扩展了，而通过这个成员变量，二者联系起来了，就像有座桥一样。
