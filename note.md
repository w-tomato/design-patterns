# Java设计模式笔记

## 0. 设计模式的六大原则
### 0.1 单一职责原则 （简单来说：一个类只负责一个功能领域中的相应职责）
    一个类只负责一个功能领域中的相应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。
    如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。
### 0.2 开闭原则 （简单来说：对扩展开放，对修改关闭）
    所谓的开闭，也就是说对扩展是开放的，对修改是关闭的。
    主要是为了可以更好的扩展和维护代码，增加新功能是对原有代码进行修改可能会影响已有功能，造成危险，比如修改了一个bug，可能会引发其他bug。
### 0.3 里氏替换原则 （简单来说：子类可以替换父类，但是父类不能替换子类）
    里氏替换原则的核心思想是，子类对象能够完全替代父类对象，而不会影响程序的正确性。
    比如说，有一个父类叫做动物，有一个抽象方法叫做eat，有两个子类，一个狗一个猫，狗和猫都继承自动物类，如果他们实现eat方法的时候，狗吃骨头，猫吃鱼，这样的话没问题
    但如果猫类实现eat方法的时候只打印了一个字符串，就可能导致程序错误，就违反了里氏替换原则。
### 0.4 依赖倒置原则 （简单来说：通过依赖抽象的接口来依赖具体的类，而不是直接依赖某个类）
    依赖倒置原则的核心思想是，要依赖于抽象，不要依赖于具体。
    比如说，有一个类叫做电脑，这个电脑有一个方法叫做work，这个方法需要一个鼠标对象，如果我们在这个方法中直接new一个鼠标对象，那么这个电脑就依赖于鼠标这个具体的类了。
    如果我们把这个鼠标抽象成一个接口，然后让具体的鼠标类实现这个接口，那么这个电脑就依赖于鼠标这个抽象的接口了，这样的话，就可以让这个电脑使用任何实现了鼠标接口的类了。
### 0.5 接口隔离原则（简单来说：使用多个专门的接口，而不是使用单一的总接口）
    接口隔离原则的核心思想是，使用多个专门的接口，而不是使用单一的总接口，也就是说，一个类对另一个类的依赖应该建立在最小的接口上。
    举个例子，假设有一个接口IAnimal，里面有eat() 和 fly()，现在Bird和Fish类都继承了这个接口，但是，Fish 并不需要实现 fly() 方法，因为鱼是不能飞行的。
    这时候，就可以使用接口隔离原则，将 Animal 接口拆分成两个接口：IEatable 和 IFlyable，分别包含 eat() 和 fly() 方法，让这两个类分别实现，提高了代码的可维护性和灵活性。 
### 0.6 迪米特法则（简单来说：用别的类要通过别的类所属的Service操作，不要直接碰别的类）
    迪米特法则的核心思想是，一个对象应该对其他对象保持最少的了解，也就是说，一个类应该对自己需要耦合或调用的类知道的最少，类的内部如何实现与调用者或者依赖者没关系，调用者或者依赖者只需要知道它需要的方法即可。
    举个例子，假设有一个学校管理系统，其中包含了很多类，比如`Teacher`、`Student`、`Course` 等等。现在有一个需求，要求查询某个学生的课程信息。
    如果按照迪米特法则的原则来设计，我们应该让 `Student` 类只关心自己的信息，而不关心其他对象的信息。因此，我们可以引入一个 `CourseService` 类，专门负责查询课程信息，
    `Student` 类只需要调用 `CourseService` 类的方法即可，而不需要直接与 `Course` 类交互。这样，就降低了 `Student` 类和 `Course` 类之间的耦合度，提高了代码的灵活性和可维护性。


## 一、创建型模式
对象实例化的模式，创建型模式用于解耦对象的实例化过程。
### 1.1 [单例模式](src/main/java/org/bradaier/designpatterns/creational/singleton/DCL.java)
    最简单的就是饿汉，直接初始化一个静态变量，每次有人调用getInstance()方法时，直接返回这个静态变量即可。
    但是这样的话，就会在类加载的时候就创建这个实例，如果这个实例很大，而且不一定会被使用，那么就会造成内存的浪费。
    所以，我们可以使用懒汉模式，也就是在第一次使用的时候才创建这个实例，但是这样的话，就会有线程安全的问题，所以我们可以使用双重检查锁定的方式来解决这个问题。
    但是这样的话，还是会有问题，就是在JVM中，创建对象和赋值是分开的，也就是说，可能会出现先赋值，后创建对象的情况，这样的话，就会出现问题。
    所以，我们可以使用volatile关键字来解决这个问题，这样的话，就会强制线程每次都去主内存中读取变量的值，而不是从线程的私有内存中读取变量的值。
    也可以使用静态内部类的方式来实现单例模式，这样的话，就可以保证线程安全，也可以保证懒加载，而且也不会有性能问题。
    最后，还可以使用枚举的方式来实现单例模式，这样的话，就可以保证线程安全，也可以保证懒加载，而且也不会有性能问题，而且还可以防止反序列化的时候创建新的对象。

### 1.2 [工厂模式](src/main/java/org/bradaier/designpatterns/creational/factory/abstractf/IProductFactory.java)
    简单工厂模式：我有一个大工厂，里面全是if else， 你告诉我你要啥车，宝马，奥迪都能造
    工厂方法模式：我有一个工厂接口，同时有多个具体的工厂实现这个接口，宝马工厂造宝马，奥迪工厂造奥迪，这样没了if else，要啥车就用啥工厂造
    抽象工厂模式：有两个维度
               第一个维度：我抽象出了一个手机产品接口，所有品牌的手机都得实现这个接口，同时抽象了一个路由器产品接口，所有品牌的路由器都得实现这个接口
               第二个维度：我抽象出了一个厂商接口，这个接口定义了要会生产手机，也要会生产路由器
               这样的好处就是两个维度都可以扩展。

### 1.3 [建造者模式](src/main/java/org/bradaier/designpatterns/creational/builder/demo1/AbstractBuilder.java) 
    建造者模式：就是一个抽象建造者类，这个抽象建造者类可以有多个具体的建造者类，这些具体的建造者类都继承自抽象建造者类，每个具体的建造者类都可以创建一种产品类的实例。
    与工厂模式的区别在于工厂模式最终目的是创建不同的对象，比如创建手机对象和路由器对象，但建造者模式是我就要建造手机，但是有的建造者建造手机用的是高通处理器，有的建造者建造手机用的是联发科处理器，这个可以由用户来自定义，而工厂模式是由工厂来决定的。
    所以也可以简单理解为工厂生产处不同的产品，而建造者生产相同的产品，但是产品的组成不同。

### 1.4 [原型模式](src/main/java/org/bradaier/designpatterns/creational/prototype/PrototypeObject.java)
    原型模式：定义一个原形对象，这个对象需要两个步骤，一个是实现Cloneable接口，一个是重写clone()方法，这个方法的返回值是这个对象的一个浅拷贝。
    当创建新的对象实例比从头开始构建更加昂贵或复杂时，使用原型模式可以通过复制现有对象来节省时间和资源。

## 二、结构型模式
从程序的结构上实现松耦合，从而可以扩大整体的类结构，用来解决更大的问题。
### 2.1 [适配器模式](src/main/java/org/bradaier/designpatterns/structural/adapter/XiaoMiAdapter.java)
    适配器模式：适配器模式适用于需要将现有的类或接口转换为其他类或接口以满足特定需求的场景
    比如Mac只有雷电3接口，插不了USB，就需要一个适配器来转换一下，这样就可以插USB了。详细看例子中解释
    而这个适配器可以是各个牌子的, 所以可以定义一个接口来定义功能，这些适配器都实现这个接口。
    当然U盘也可以是各个牌子的，所以也可以定义一个接口来定义功能，这些U盘都实现这个接口。
    其实核心就在于某个充当适配器或充当桥的类  有一个通过构造器传入的带一定功能方法的成员变量，这个成员变量可以是接口，也可以是抽象类，也可以是具体类。桥接模式也是这个思想。

### 2.2 [桥接模式](src/main/java/org/bradaier/designpatterns/structural/bridge/AbstractComputer.java)
    桥接模式：网上都说桥接模式适用于需要将抽象部分与其实现部分分离的场景，但是我分不清楚抽象部分和实现部分是什么，所以我就自己理解了一下。我觉得很像适配器模式，
    在上边的适配器模式中，电脑想用U盘，就需要适配器，但是U盘可以有很多牌子的，所以可以定义接口来供U盘实现，桥接模式的话我理解就是适配器例子中的电脑也有很多种，
    比如Mac，小米，华为，这些电脑都可以用U盘，但是他们的接口不一样，所以就需要一个抽象类来供各种电脑实现，而桥接模式不需要像适配器模式一样真的创建一个类来当做适配器，
    这个桥是一个想象中的桥，其实核心思想是一样的，就像上边适配器模式笔记的最后一句话，这里的桥接模式就是将电脑抽象出来一个抽象类，
    这个抽象类像适配器一样有一个成员变量，这个成员变量就是U盘的抽象类，这样电脑也抽象了，可以扩展了，U盘也抽象了，也可以扩展了，而通过这个成员变量，二者联系起来了，就像有座桥一样。

### 2.3 [组合模式](src/main/java/org/bradaier/designpatterns/structural/composite/AbstractFile.java)
    组合模式：组合模式适用于需要将对象组合成树形结构以表示“部分-整体”的层次结构的场景。
    比如文件夹和文件，文件夹可以包含文件夹，也可以包含文件，文件夹和文件都是文件的一种，所以可以定义一个抽象类，这个抽象类有一个成员变量，这个成员变量是一个List，
    这个List里面可以放文件夹，也可以放文件，这样就可以实现文件夹里面可以包含文件夹，也可以包含文件了。

### 2.4 [装饰器模式](src/main/java/org/bradaier/designpatterns/structural/decorator/AbstractDecorator.java)
    装饰器模式：装饰器模式适用于需要动态地为对象添加额外的职责的场景。
    其实主要的好处是可以动态的扩展和易于维护，对于网上说的避免类爆炸的情况，我觉得并不明显，比如我要给一个形状类加一个颜色功能，我通过继承的方式创建一个颜色类继承形状类就行了，
    但是用装饰器模式还需要创建一个装饰器抽象类，还需要一个具体的颜色装饰器类，这样就比继承方式的类还多了，所以这种情况并不适合使用装饰器，但是下边这个例子还可以：
    假设我们有一个简单的咖啡店程序，需要实现多种不同类型的咖啡（比如美式咖啡、拿铁咖啡、卡布奇诺等），每种咖啡可以加不同的配料（比如牛奶、糖、焦糖等）。
    如果使用继承模式来实现，可能会产生大量的子类，例如：
    美式咖啡、美式咖啡加牛奶、美式咖啡加糖、美式咖啡加焦糖、美式咖啡加牛奶和糖、美式咖啡加牛奶和焦糖、美式咖啡加糖和焦糖等等
    最可怕的是、如果还有一个新的咖啡类型，那么上述所有的子类都要重新创建一遍，
    这样就会产生很多类，代码难以维护且混乱。而如果使用装饰器模式，则可以将咖啡和配料分别抽象为两个类，然后通过不同的装饰器进行动态组合。例如：
    美式咖啡
    牛奶装饰器
    糖装饰器
    焦糖装饰器
    这样即使加咖啡种类，也可以服用这些装饰类，因为其他咖啡种类和美式咖啡都实现的同一个接口，这样可以避免类爆炸问题，
    同时也更加灵活和易于扩展。例如，如果需要添加新的咖啡或配料，只需创建对应的类和装饰器即可，不用修改原有的代码。

### 2.5 [外观模式](src/main/java/org/bradaier/designpatterns/structural/facade/ShapeFacade.java)
    外观模式：外观模式适用于需要为复杂的子系统提供一个简单的接口的场景。
    这个就很简单了，就相当于在客户端和后台服务中间加一层，比如电脑开机，需要按下电源键，然后CPU开始工作，内存开始工作，硬盘开始工作，但是我们只需要给客户端一个开机功能就行了，
    就是将复杂的子系统封装起来，对外提供一个简单的接口，这样就可以屏蔽内部的复杂性了，但是这个缺点就很明显了，不符合开闭原则，如果要增加一个功能，就需要修改外观类了。甚至如果之前的硬盘坏了，
    换了一个新的，那原来提供的那个方法也不能用了。

### 2.6 [过滤器模式](src/main/java/org/bradaier/designpatterns/structural/filter/Filter.java)
    过滤器模式：过滤器模式适用于需要根据条件从一个对象列表中筛选出一部分对象的场景。
    这个也很简单，就是把过滤器条件单抽成一个类了，建一个接口，让所有过滤规则都实现这个接口，比如我们有一个人类，这个人类有姓名、性别、年龄等属性，
    我们可以建一个过滤接口，里面有一个过滤方法，入参出参都是List<Person>，然后比如建一个过滤男性的类过滤出所有的男性，再建一个过滤女性的类过滤出所有的女性，等等，没啥意思。



